<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四则运算练习器</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <style>
        /* 这里是你原有的CSS样式，为了简洁已省略 */
        /* 请确保这里包含你之前所有的样式代码 */
    </style>
</head>
<body>
    <!-- 这里是你原有的HTML结构，为了简洁已省略 -->
    <!-- 请确保这里包含你之前所有的HTML代码 -->

    <script>
        // ==================== 状态管理 ====================
        let state = {
            mode: 'addSub',
            problems: [],
            answers: {},
            startTime: null,
            timer: null,
            timeLeft: 600,
            isActive: false,
            totalProblems: 10,
            isSmartPractice: false,
            knowledgeTags: {},
            originalWrongProblem: null,
            operatorStats: { '+': 0, '-': 0, '×': 0, '÷': 0 }
        };

        // ==================== 修改后的异步题目生成器 ====================
        const ProblemGenerator = {
            /**
             * 异步分批生成题目（解决页面卡顿问题）
             * 立刻显示第1题，剩余的题目在后台生成
             */
            generateProblems(count, mode, updateCallback) {
                const allProblems = [];
                const BATCH_SIZE = 3;
                
                const generatorMap = {
                    '+': () => this.generateAddProblem(),
                    '-': () => this.generateSubProblem(),
                    '×': () => this.generateMulProblem(),
                    '÷': () => this.generateDivProblem()
                };
                
                // 1. 立即生成并返回第1题
                const firstProblem = this.generateSingleProblemByMode(mode);
                allProblems.push(firstProblem);
                if (updateCallback) updateCallback([...allProblems]);
                
                // 2. 在空闲时间分批生成剩余题目
                const remainingCount = count - 1;
                const operatorQueue = this.createOperatorQueue(remainingCount, mode);
                
                const generateRemaining = async () => {
                    for (let i = 0; i < operatorQueue.length; i += BATCH_SIZE) {
                        const batchOps = operatorQueue.slice(i, i + BATCH_SIZE);
                        await new Promise(resolve => setTimeout(resolve, 0));
                        
                        batchOps.forEach(op => {
                            const problem = generatorMap[op]();
                            allProblems.push(problem);
                        });
                        
                        if (updateCallback && i + BATCH_SIZE < operatorQueue.length) {
                            updateCallback([...allProblems]);
                        }
                    }
                    
                    // 3. 全部完成后，打乱顺序（除了第1题）
                    const first = allProblems[0];
                    const rest = allProblems.slice(1);
                    this.shuffleArray(rest);
                    const finalProblems = [first, ...rest];
                    
                    const finalProblemsWithMeta = finalProblems.map((p, index) => ({
                        ...p,
                        id: index,
                        userAnswer: null,
                        isCorrect: false,
                        timestamp: Date.now()
                    }));
                    
                    if (updateCallback) {
                        updateCallback(finalProblemsWithMeta);
                    }
                    return finalProblemsWithMeta;
                };
                
                generateRemaining();
                
                // 先返回首题
                return allProblems.map((p, index) => ({
                    ...p,
                    id: index,
                    userAnswer: null,
                    isCorrect: false,
                    timestamp: Date.now()
                }));
            },
            
            /**
             * 根据模式生成一道题（用于生成首题）
             */
            generateSingleProblemByMode(mode) {
                if (mode === 'addSub') {
                    return Math.random() < 0.5 ? this.generateAddProblem() : this.generateSubProblem();
                } else {
                    const ops = ['+', '-', '×', '÷'];
                    const op = ops[Math.floor(Math.random() * 4)];
                    if (op === '+') return this.generateAddProblem();
                    if (op === '-') return this.generateSubProblem();
                    if (op === '×') return this.generateMulProblem();
                    return this.generateDivProblem();
                }
            },
            
            /**
             * 创建运算符队列，确保运算类型分布均匀
             */
            createOperatorQueue(count, mode) {
                const queue = [];
                
                if (mode === 'addSub') {
                    const half = Math.floor(count / 2);
                    for (let i = 0; i < half; i++) queue.push('+', '-');
                    if (count % 2) queue.push(Math.random() < 0.5 ? '+' : '-');
                } else {
                    const ops = ['+', '-', '×', '÷'];
                    const base = Math.floor(count / 4);
                    for (let i = 0; i < base; i++) ops.forEach(op => queue.push(op));
                    
                    const remainder = count % 4;
                    for (let i = 0; i < remainder; i++) {
                        queue.push(ops[Math.floor(Math.random() * 4)]);
                    }
                }
                
                this.shuffleArray(queue);
                return queue;
            },
            
            // 以下是原有的四个具体题目生成函数（保持不变）
            generateAddProblem() {
                const result = Math.floor(Math.random() * 101);
                const a = Math.floor(Math.random() * (result + 1));
                const b = result - a;
                const unknownPos = Math.floor(Math.random() * 3);
                return { a, b, op: '+', result, unknownPos };
            },
            
            generateSubProblem() {
                const result = Math.floor(Math.random() * 101);
                const b = Math.floor(Math.random() * 101);
                let a = result + b;
                if (a > 100) { a = 100; b = a - result; }
                const unknownPos = Math.floor(Math.random() * 3);
                return { a, b, op: '-', result, unknownPos };
            },
            
            generateMulProblem() {
                let a, b;
                if (Math.random() < 0.7) {
                    a = Math.floor(Math.random() * 8) + 2;
                    b = Math.floor(Math.random() * Math.floor(100 / a)) + 1;
                } else {
                    a = Math.random() < 0.5 ? 1 : Math.floor(Math.random() * 10) + 1;
                    b = Math.floor(Math.random() * Math.floor(100 / a)) + 1;
                }
                const result = a * b;
                const unknownPos = Math.floor(Math.random() * 3);
                return { a, b, op: '×', result, unknownPos };
            },
            
            generateDivProblem() {
                let result, b;
                if (Math.random() < 0.7) {
                    result = Math.floor(Math.random() * 10) + 1;
                    b = Math.floor(Math.random() * 10) + 1;
                } else {
                    result = Math.floor(Math.random() * 20) + 1;
                    b = Math.floor(Math.random() * 10) + 1;
                }
                let a = result * b;
                while (a > 100) {
                    b = Math.floor(Math.random() * 10) + 1;
                    a = result * b;
                }
                const unknownPos = Math.floor(Math.random() * 3);
                return { a, b, op: '÷', result, unknownPos };
            },
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            },
            
            generateSimilarProblem(originalProblem) {
                const keepSameOp = Math.random() < 0.7;
                let newOp = originalProblem.op;
                if (!keepSameOp) {
                    const allOps = ['+', '-', '×', '÷'];
                    const otherOps = allOps.filter(op => op !== originalProblem.op);
                    newOp = otherOps[Math.floor(Math.random() * otherOps.length)];
                }
                let newProblem;
                if (newOp === '+') newProblem = this.generateAddProblem();
                else if (newOp === '-') newProblem = this.generateSubProblem();
                else if (newOp === '×') newProblem = this.generateMulProblem();
                else if (newOp === '÷') newProblem = this.generateDivProblem();
                newProblem.unknownPos = originalProblem.unknownPos;
                return newProblem;
            }
        };

        // ==================== 知识点分析器（保持不变）====================
        const KnowledgeAnalyzer = {
            analyzeProblem(problem) {
                const tags = [];
                if (problem.op === '+') tags.push('加法');
                else if (problem.op === '-') tags.push('减法');
                else if (problem.op === '×') tags.push('乘法');
                else if (problem.op === '÷') tags.push('除法');
                if (problem.unknownPos === 0) tags.push('求结果');
                else if (problem.unknownPos === 1) tags.push('求前数');
                else tags.push('求后数');
                return tags;
            },
            
            generateSimilarProblems(originalProblem, count = 3) {
                const similarProblems = [];
                for (let i = 0; i < count; i++) {
                    const similar = ProblemGenerator.generateSimilarProblem(originalProblem);
                    similarProblems.push(similar);
                }
                return similarProblems;
            }
        };

        // ==================== 核心：修改题目生成调用处 ====================
        // 找到并修改启动练习的函数（例如 startExercise）
        // 将原来的同步调用改为异步调用
        function startExercise() {
            // ... 其他初始化代码 ...
            
            // === 关键修改行 ===
            // 旧的同步调用（会卡顿）：
            // state.problems = ProblemGenerator.generateProblems(state.totalProblems, state.mode);
            
            // 新的异步调用（解决卡顿）：
            state.problems = ProblemGenerator.generateProblems(
                state.totalProblems,
                state.mode,
                // 新增的回调函数参数
                (newProblems) => {
                    state.problems = newProblems;
                    // 确保 renderProblems 函数存在
                    if (typeof renderProblems === 'function') {
                        renderProblems();
                    }
                }
            );
            // === 关键修改结束 ===
            
            // ... 后续渲染和启动计时器代码 ...
        }

        // ==================== 其他原有函数（保持不变）====================
        // 这里应包含你原有的 renderProblems、checkAnswer、updateTimer 等所有函数
        // 为了简洁，此处省略，但实际文件中必须有
        
        console.log('修正版四则运算练习器加载完成！');
        console.log('版本说明：修复了乘除题目生成问题，并采用异步生成解决卡顿');
    </script>
</body>
</html>
